# TP_Synth-se_PILLOT_LABOURE
Labour√© Manon
Pillot Matthieu 

We have created one file per question and grouped the useful functions in a file named 'function.c.' However, to facilitate review, we have added comments at the top of the page for each function's initial appearance, containing the code of the function. The 'function.h' file contains all the definitions of our constants, as well as function prototypes and our includes.

Q1 : The goal of this first question is to create a simple prompt that awaits a command input after displaying a welcome message. To display this welcome message easily, we define macros for all our messages in our .h file; this allows us to use the write() function much more quickly. After calling our welcome() function, we create the loop allowing the shell to wait for a command. The read() function reads the user's input, and then we add a comparison condition between our command and the string "exit"  to determine when to exit the loop. If this condition is not met, our program returns an error message and goes back to waiting.

Q2 : We now want our shell to be able to execute a simple command (without arguments) and go back to waiting once it is finished. We take care to create a child process for each command so that each of them is executed in this process, and not in the parent process, which is responsible for displaying the command prompt's waiting message once the child has successfully terminated.

Q3 : Our previous programs already handle the exit command, and we are adding support for the Ctrl + D command. When this key combination is pressed, no characters are added, so the exit condition used is the comparison of the number of characters in the command with 0.

Q4 : To retrieve the exit codes of our programs, we have to focus on the value of "status" returned by WEXITSTATUS() and WIFEXITED(). Don't forget to convert this value to a string using sprintf to be able to display it using write(). We also had to make a few small modifications to the displayed messages to achieve the desired output.

Q5 : We are now focusing on the duration of the programs executed by our shell, specifically the execution time of the child process. To achieve this, we are using the clock_gettime system call. After reading the manual for this call, we have defined two timespec structures, start and end, and we are using the times recorded in seconds and nanoseconds. To display the time effectively, we have implemented a loop that shows the time in milliseconds as long as it is less than 1 second. We take care to convert our long-type variables to strings using snprintf to use them in the write() function.  We have consolidated all of this into a single function called display_execTime_exitCode_prompt() to simplify the readability of the main program.

Q6: Our goal now is to enable our shell to execute more complex commands that take into account one or more arguments. For this purpose, we have created our function exec_complex_command(). This function relies on the use of execvp(). Once the command is entered by the user, the function splits this line into different words using the strtok() function, and each word is stored in an array. Now, it is a matter of passing these words as arguments to execvp() to achieve our goal. 

Q7 : We now want to manage redirections to stdin and stdout using '<' and '>'. To achieve this, we modify the function from the previous question to search for these symbols among the arguments stored in our array. For each of the 2 symbols, we associate the desired action using calls to dup2 and open. We make sure to remove the redirection symbols before passing args as an argument to execvp because they are not valid arguments and would result in an error.

Q8 : Our goal in this question is to use a more concise redirection technique with the pipe symbol '|'. We use the 'pipe' system call to create the pipe, and then create a child process in which we close the write end of the pipe, redirect its standard input to the read end of the pipe using 'dup2', and close the read end of the pipe. Afterward, we execute the command after the pipe with its arguments using 'execvp'. In the parent process, we close the read end of the pipe, redirect its standard output to the write end of the pipe using 'dup2', and close the write end of the pipe. Additionally, we remove the '|' and the command after the pipe from the 'args' array.
